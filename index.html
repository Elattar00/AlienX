<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magical Saturn Particle System</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        /* Prevent pull-to-refresh and scrolling on mobile */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Inter', sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(10, 10, 20, 0.65);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* Deep Space Gradient */
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .interactive-element {
            pointer-events: auto;
        }

        .input_video { 
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 1px;
            height: 1px;
            pointer-events: none;
            z-index: -1;
        }

        /* Mirrored Canvas (Selfie Mode) */
        .output_canvas {
            transform: scaleX(-1); 
        }
        
        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 3px solid #a855f7;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .btn-pulse {
            animation: scanner 2s infinite;
        }
        @keyframes scanner {
            0% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(168, 85, 247, 0); }
            100% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0); }
        }

        .theme-btn.active {
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
            transform: scale(1.15);
        }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-4 md:p-6 safe-area-inset">
        
        <!-- Top Section -->
        <div class="flex flex-col md:flex-row justify-between items-start gap-4">
            
            <!-- Title Card -->
            <div class="glass-panel rounded-2xl p-4 text-white w-full md:w-auto md:max-w-xs interactive-element transition-all border-l-4 border-purple-500">
                <div class="flex justify-between items-center mb-2">
                    <h1 class="text-lg md:text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-300 to-pink-400">
                        Cosmic Saturn
                    </h1>
                    <div class="flex items-center text-[10px] md:text-xs bg-black bg-opacity-40 rounded-full px-2 py-1 border border-white/10">
                        <span id="status-indicator" class="w-1.5 h-1.5 rounded-full bg-yellow-400 mr-2 animate-pulse"></span>
                        <span id="status-text">Standby</span>
                    </div>
                </div>
                
                <div class="text-[11px] md:text-xs text-gray-300 space-y-1 font-medium tracking-wide">
                    <p class="flex items-center"><span class="mr-2 text-purple-400">ü§è</span> Pinch to Resize</p>
                    <p class="flex items-center"><span class="mr-2 text-purple-400">üëã</span> Move Hand to Rotate</p>
                </div>
            </div>

            <!-- Camera & Controls -->
            <div class="glass-panel rounded-2xl p-2 flex flex-row md:flex-col items-center gap-3 interactive-element">
                <!-- Camera Preview -->
                <div class="relative w-28 h-20 md:w-36 md:h-28 bg-black rounded-xl overflow-hidden border border-gray-700 shadow-2xl shrink-0">
                    <video class="input_video" playsinline webkit-playsinline></video>
                    <canvas class="output_canvas absolute top-0 left-0 w-full h-full object-cover opacity-90"></canvas>
                    
                    <!-- Start Button -->
                    <div id="start-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 z-20 cursor-pointer backdrop-blur-sm">
                        <button id="start-btn" class="btn-pulse bg-purple-600 hover:bg-purple-500 text-white text-[10px] font-bold py-1.5 px-4 rounded-full transition border border-purple-400 shadow-[0_0_15px_rgba(168,85,247,0.5)]">
                            AWAKEN
                        </button>
                    </div>

                    <div id="loading-spinner" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 hidden">
                        <div class="loader"></div>
                    </div>
                    
                    <div id="error-overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-red-900 bg-opacity-95 hidden p-2 text-center z-30">
                        <p id="error-title" class="text-[10px] font-bold text-white mb-1">Error</p>
                        <p id="error-desc" class="text-[8px] text-gray-200 leading-tight">Check permissions.</p>
                    </div>
                </div>
                
                <!-- Themes -->
                <div class="flex flex-col justify-center w-full px-1">
                    <label class="text-[9px] text-gray-500 mb-1 hidden md:block uppercase tracking-wider">Cosmic Themes</label>
                    <div class="flex items-center gap-3 overflow-x-auto pb-1" id="theme-container"></div>
                </div>
            </div>
        </div>

        <!-- Footer Stats -->
        <div class="flex justify-end pointer-events-none">
            <div class="glass-panel rounded-lg px-3 py-1.5 text-right opacity-80 scale-90 origin-bottom-right border-r-2 border-purple-500">
                <div class="text-[9px] text-purple-300 uppercase tracking-widest">Direct Control</div>
                <div class="text-sm font-mono text-white font-bold flex items-center justify-end gap-2">
                    ACTIVE <span class="w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse"></span>
                </div>
            </div>
        </div>
    </div>

<script>
    // --- Config ---
    const CONFIG = {
        particleCount: 15000, 
        sphereRadius: 18,
        ringInner: 26,
        ringOuter: 56,
        
        // INTERACTION CONFIG (Direct Control)
        lerpFactor: 0.15, // Smoothness of the follow movement
        deadZone: 0.02,
        stabilityThreshold: 0.01, // Jitter removal: Hand must move > 1% to update
        historySize: 2
    };

    // --- Magical Themes ---
    const THEMES = [
        { name: 'Nebula', core: '#8A2387', ring: '#F27121' },   // Purple -> Orange
        { name: 'Cyber',  core: '#00f260', ring: '#0575E6' },   // Green -> Blue
        { name: 'Golden', core: '#BF953F', ring: '#FCF6BA' },   // Gold -> Pale Gold
        { name: 'Frost',  core: '#00d2ff', ring: '#3a7bd5' },   // Cyan -> Deep Blue
        { name: 'Crimson',core: '#870000', ring: '#190A05' }    // Red -> Dark
    ];
    let currentTheme = THEMES[0];

    // --- State ---
    const state = {
        targetScale: 1,
        currentScale: 1,
        
        // Rotation State
        rotY: 0,
        rotX: 0.2,
        
        targetRotationY: 0,
        targetRotationX: 0.2,
        
        handDetected: false,
        xHistory: [],
        yHistory: [],
        
        lastStableX: 0.5,
        lastStableY: 0.5
    };

    // --- Texture Engine: "Stardust" ---
    function getTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        const cx = 32;
        const cy = 32;

        // 1. Soft Halo
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
        gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        // 2. Sharp Star Core
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        ctx.fill();

        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    // --- Three.js Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    
    // Magical Fog
    scene.fog = new THREE.FogExp2(0x1a0b2e, 0.008); 

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 80;
    camera.position.y = 15;
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ 
        antialias: false, 
        alpha: true, 
        powerPreference: "high-performance" 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); 
    container.appendChild(renderer.domElement);

    // --- Background Stars (Twinkling) ---
    const starGeo = new THREE.BufferGeometry();
    const starPos = [];
    const starSizes = [];
    for(let i=0; i<800; i++) {
        starPos.push((Math.random() - 0.5) * 600);
        starPos.push((Math.random() - 0.5) * 600);
        starPos.push((Math.random() - 0.5) * 600);
        starSizes.push(Math.random());
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
    
    const starMat = new THREE.PointsMaterial({
        color: 0xffffff, 
        size: 0.8, 
        transparent: true, 
        opacity: 0.8,
        map: getTexture(),
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // --- Saturn Particles ---
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    const phases = []; // For twinkling animation
    
    const colorCore = new THREE.Color(currentTheme.core);
    const colorRing = new THREE.Color(currentTheme.ring);
    
    // 1. Planet Core
    const coreCount = Math.floor(CONFIG.particleCount * 0.4);
    for (let i = 0; i < coreCount; i++) {
        const phi = Math.acos(-1 + (2 * i) / coreCount);
        const theta = Math.sqrt(coreCount * Math.PI) * phi;
        
        const fuzz = (Math.random() - 0.5) * 0.5; 
        const r = CONFIG.sphereRadius + fuzz; 
        
        const x = r * Math.cos(theta) * Math.sin(phi);
        const y = r * Math.sin(theta) * Math.sin(phi);
        const z = r * Math.cos(phi);

        positions.push(x, y, z);
        
        // Color Banding
        const lat = (y / CONFIG.sphereRadius + 1) * 0.5;
        const bandMix = Math.sin(lat * 25) * 0.15 + 0.85; 
        
        const pc = colorCore.clone();
        const hsl = {};
        pc.getHSL(hsl);
        pc.setHSL(hsl.h, hsl.s, hsl.l * bandMix);
        colors.push(pc.r, pc.g, pc.b);
        
        sizes.push(1.0 + Math.random() * 0.5);
        phases.push(Math.random() * Math.PI * 2);
    }
    
    // 2. Rings
    const ringCount = CONFIG.particleCount - coreCount;
    for (let i = 0; i < ringCount; i++) {
        const r = THREE.MathUtils.randFloat(CONFIG.ringInner, CONFIG.ringOuter);
        const theta = Math.random() * Math.PI * 2;
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        const y = (Math.random() - 0.5) * 0.2; 

        positions.push(x, y, z);
        
        const mix = (r - CONFIG.ringInner) / (CONFIG.ringOuter - CONFIG.ringInner);
        const c = new THREE.Color().lerpColors(colorCore, colorRing, mix);
        
        colors.push(c.r, c.g, c.b);
        sizes.push(0.5 + Math.random() * 0.5);
        phases.push(Math.random() * Math.PI * 2);
    }

    particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    particlesGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    particlesGeometry.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));

    const particlesMaterial = new THREE.PointsMaterial({
        size: 1.0, 
        map: getTexture(), 
        vertexColors: true,
        transparent: true,
        opacity: 1.0,
        blending: THREE.AdditiveBlending, // Glowy look
        depthWrite: false,
        sizeAttenuation: true
    });

    const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particleSystem);

    // --- UI Logic ---
    const themeContainer = document.getElementById('theme-container');
    
    THEMES.forEach((theme, index) => {
        const btn = document.createElement('div');
        btn.className = `theme-btn min-w-[24px] w-6 h-6 rounded-full cursor-pointer border-2 border-white/20 transition-all duration-200 ${index === 0 ? 'active' : ''}`;
        btn.style.background = `linear-gradient(135deg, ${theme.core} 0%, ${theme.ring} 100%)`;
        btn.addEventListener('click', () => applyTheme(theme, btn));
        themeContainer.appendChild(btn);
    });

    function applyTheme(theme, btnElement) {
        currentTheme = theme;
        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
        if(btnElement) btnElement.classList.add('active');

        const colorC = new THREE.Color(theme.core);
        const colorR = new THREE.Color(theme.ring);
        const colorsAttr = particlesGeometry.attributes.color;
        const positionsAttr = particlesGeometry.attributes.position;
        const coreCount = Math.floor(CONFIG.particleCount * 0.4);
        
        for(let i=0; i < coreCount; i++) {
            const y = positionsAttr.getY(i);
            const lat = (y / CONFIG.sphereRadius + 1) * 0.5;
            const bandMix = Math.sin(lat * 25) * 0.15 + 0.85;
            const pc = colorC.clone();
            const hsl = {};
            pc.getHSL(hsl);
            pc.setHSL(hsl.h, hsl.s, hsl.l * bandMix);
            colorsAttr.setXYZ(i, pc.r, pc.g, pc.b);
        }
        
        for(let i = coreCount; i < CONFIG.particleCount; i++) {
            const x = positionsAttr.getX(i);
            const z = positionsAttr.getZ(i);
            const dist = Math.sqrt(x*x + z*z);
            let mix = (dist - CONFIG.ringInner) / (CONFIG.ringOuter - CONFIG.ringInner);
            if (mix < 0) mix = 0; if (mix > 1) mix = 1;
            const c = new THREE.Color().lerpColors(colorC, colorR, mix);
            colorsAttr.setXYZ(i, c.r, c.g, c.b);
        }
        colorsAttr.needsUpdate = true;
    }

    function getWeightedAverage(history) {
        if(history.length === 0) return 0.5;
        let sum = 0, weightSum = 0;
        for(let i=0; i<history.length; i++) {
            const w = i + 1;
            sum += history[i] * w;
            weightSum += w;
        }
        return sum / weightSum;
    }

    // --- MediaPipe ---
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    const statusText = document.getElementById('status-text');
    const statusInd = document.getElementById('status-indicator');
    const loader = document.getElementById('loading-spinner');
    const startBtn = document.getElementById('start-btn');
    const startOverlay = document.getElementById('start-overlay');
    const errorOverlay = document.getElementById('error-overlay');

    function onResults(results) {
        if (loader.style.display !== 'none') {
            loader.style.display = 'none';
            statusText.textContent = "System Active";
            statusInd.classList.replace('bg-yellow-400', 'bg-green-400');
        }

        canvasElement.width = results.image.width;
        canvasElement.height = results.image.height;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // Draw image mirrored visually
        canvasCtx.filter = 'grayscale(100%) contrast(1.2) brightness(0.8)';
        canvasCtx.save();
        canvasCtx.scale(-1, 1);
        canvasCtx.drawImage(results.image, -canvasElement.width, 0, canvasElement.width, canvasElement.height);
        canvasCtx.restore();
        canvasCtx.filter = 'none'; 
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            state.handDetected = true;

            const themeColor = currentTheme.core; 
            
            // Re-draw image normally for overlay consistency
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.filter = 'grayscale(100%) contrast(1.2) brightness(0.8)';
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.filter = 'none';

            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: 'rgba(255,255,255,0.3)', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: themeColor, lineWidth: 1, radius: 2});

            state.xHistory.push(landmarks[9].x);
            state.yHistory.push(landmarks[9].y);
            if(state.xHistory.length > CONFIG.historySize) state.xHistory.shift();
            if(state.yHistory.length > CONFIG.historySize) state.yHistory.shift();

            const smoothedX = getWeightedAverage(state.xHistory);
            const smoothedY = getWeightedAverage(state.yHistory);

            // --- DIRECT MAPPING LOGIC (No Inertia) ---
            
            // Calculate differences for stability check
            const deltaX = Math.abs(smoothedX - state.lastStableX);
            const deltaY = Math.abs(smoothedY - state.lastStableY);
            
            let stableX = state.lastStableX;
            let stableY = state.lastStableY;

            // STABILITY GATE: Only update if moved enough
            if (deltaX > CONFIG.stabilityThreshold) {
                state.lastStableX = smoothedX;
                stableX = smoothedX;
            }
            if (deltaY > CONFIG.stabilityThreshold) {
                state.lastStableY = smoothedY;
                stableY = smoothedY;
            }

            // Map Position Directly to Rotation Angle
            // Hand Right (x=0 due to mirror) -> Offset +0.5 -> Rotation +
            const xOffset = 0.5 - stableX; 
            const yOffset = 0.5 - stableY;
            
            const sensitivity = 5.0; // Multiplier for how much it rotates
            
            state.targetRotationY = xOffset * sensitivity;
            state.targetRotationX = yOffset * sensitivity;

            // Pinch Scale
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const wrist = landmarks[0];
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const scaleRef = Math.hypot(wrist.x - landmarks[5].x, wrist.y - landmarks[5].y);
            const normalizedOpenness = pinchDist / scaleRef;
            let expansion = (normalizedOpenness - 0.25) * 2.5; 
            if (expansion < 0.15) expansion = 0.15; 
            if (expansion > 3.5) expansion = 3.5;
            state.targetScale = expansion;

        } else {
            state.handDetected = false;
            state.targetScale = 1;
            state.xHistory = [];
            state.yHistory = [];
            
            // Gentle Idle
            state.targetRotationY += 0.001; 
            // Slowly return X to center
            state.targetRotationX = state.rotX * 0.95 + 0.2 * 0.05;
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    
    startBtn.addEventListener('click', () => {
        if (window.location.protocol === 'file:') {
            document.getElementById('error-title').textContent = "Security Error";
            document.getElementById('error-desc').textContent = "Run via local server.";
            errorOverlay.style.display = 'flex';
            return;
        }
        startOverlay.style.display = 'none';
        loader.style.display = 'flex';
        statusText.textContent = "Connecting...";
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 320 }, height: { ideal: 240 } } })
            .then(stream => {
                stream.getTracks().forEach(track => track.stop()); 
                statusText.textContent = "Calibrating...";
                cameraUtils.start().catch(console.error);
            }).catch(console.error);
    });

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // 1. Direct Control Update
        if (state.handDetected) {
            // Smoothly interpolate towards the target angle
            state.rotY += (state.targetRotationY - state.rotY) * CONFIG.lerpFactor;
            state.rotX += (state.targetRotationX - state.rotX) * CONFIG.lerpFactor;
        } else {
            // Idle behavior
            state.rotY += 0.001;
            state.rotX += (state.targetRotationX - state.rotX) * 0.05;
        }
        
        // Scale Lerp
        state.currentScale += (state.targetScale - state.currentScale) * 0.1;

        // 2. Scene Updates
        particleSystem.rotation.y = state.rotY;
        particleSystem.rotation.x = state.rotX;
        particleSystem.rotation.z = Math.cos(time * 0.1) * 0.05;

        // 3. Particle Animation (Twinkle & Flow)
        const positionsAttribute = particlesGeometry.attributes.position;
        const positionsArray = positionsAttribute.array;
        
        for (let i = 0; i < CONFIG.particleCount; i++) {
            if (i > CONFIG.particleCount * 0.4) {
                 // Rings flow
                 const ix = i * 3;
                 const iy = i * 3 + 1;
                 const iz = i * 3 + 2;
                 
                 // Magical drift
                 const x = positionsArray[ix];
                 const z = positionsArray[iz];
                 positionsArray[iy] = (Math.sin(time * 2 + x * 0.1) * 0.05) * state.currentScale;
            }
        }
        positionsAttribute.needsUpdate = true;
        
        // Scale the whole system
        particleSystem.scale.set(state.currentScale, state.currentScale, state.currentScale);

        // Background rotation
        stars.rotation.y = time * 0.01;
        
        renderer.render(scene, camera);
    }
    animate();
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
