<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Matter Control</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Inter', sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }
        
        .glass-panel {
            background: rgba(10, 10, 20, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: radial-gradient(circle at 30% 40%, rgba(59, 130, 246, 0.2) 0%, transparent 50%),
                        radial-gradient(circle at 70% 60%, rgba(168, 85, 247, 0.2) 0%, transparent 50%),
                        radial-gradient(circle at 50% 50%, #0a0510 0%, #000000 100%);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .interactive-element {
            pointer-events: auto;
        }

        .input_video { 
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 1px;
            height: 1px;
            pointer-events: none;
            z-index: -1;
        }

        /* FORCE MIRROR ALWAYS for Selfie Feel */
        .output_canvas {
            transform: scaleX(-1); 
        }
        
        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 3px solid #a855f7;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .btn-pulse { animation: scanner 2s infinite; }
        @keyframes scanner {
            0% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(168, 85, 247, 0); }
            100% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0); }
        }

        .option-btn {
            transition: all 0.3s ease;
            opacity: 0.6;
            position: relative;
        }
        .option-btn.active {
            opacity: 1;
            transform: scale(1.1);
            border-color: #a855f7;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
        }
        .option-btn::after {
            content: attr(title);
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 100;
        }
        .option-btn:hover::after {
            opacity: 1;
        }
        
        /* Scatter Warning - Now Cyan/Blue instead of Red */
        #scatter-text {
            opacity: 0;
            transition: opacity 0.2s ease;
            color: #22d3ee; 
            font-weight: bold;
            text-shadow: 0 0 5px rgba(34, 211, 238, 0.5);
        }

        /* Mobile detection helper */
        @media (max-width: 768px) {
            .mobile-only { display: block; }
            .desktop-only { display: none; }
        }
        @media (min-width: 769px) {
            .mobile-only { display: none; }
            .desktop-only { display: block; }
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="flex flex-col justify-between p-4 md:p-6 safe-area-inset">
        <div class="flex flex-col md:flex-row justify-between items-start gap-4">
            
            <!-- Info Card -->
            <div class="glass-panel rounded-2xl p-4 text-white w-full md:w-auto md:max-w-xs interactive-element border-l-4 border-purple-500 relative overflow-hidden">
                <div class="flex justify-between items-center mb-2 relative z-10">
                    <h1 class="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-300 to-pink-400">
                        Matter Control
                    </h1>
                    <div class="flex items-center text-[10px] bg-black bg-opacity-40 rounded-full px-2 py-1 border border-white/10">
                        <span id="status-indicator" class="w-1.5 h-1.5 rounded-full bg-yellow-400 mr-2 animate-pulse"></span>
                        <span id="status-text">Standby</span>
                    </div>
                </div>
                
                <div class="text-[10px] text-gray-300 space-y-1 font-medium tracking-wide relative z-10">
                    <p>✊ <b>Fist:</b> Scatter <span id="scatter-text">ACTIVE</span></p>
                    <p>✋ <b>Opening:</b> Assemble</p>
                    <p>↔️ <b>Distance:</b> Zoom In/Out</p>
                    <p class="text-cyan-400 mobile-only"><small>Particles: 10,000 (Mobile Optimized)</small></p>
                    <p class="text-cyan-400 desktop-only"><small>Particles: 12,000</small></p>
                </div>
            </div>

            <!-- Controls -->
            <div class="glass-panel rounded-2xl p-3 flex flex-col items-center gap-3 interactive-element">
                <!-- Camera -->
                <div class="relative w-32 h-24 bg-black rounded-xl overflow-hidden border border-gray-700 shadow-2xl">
                    <video class="input_video" playsinline webkit-playsinline></video>
                    <canvas class="output_canvas absolute top-0 left-0 w-full h-full object-cover opacity-90"></canvas>
                    
                    <div id="start-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 z-20 cursor-pointer backdrop-blur-sm">
                        <button id="start-btn" class="btn-pulse bg-purple-600 hover:bg-purple-500 text-white text-[10px] font-bold py-1.5 px-4 rounded-full transition border border-purple-400">
                            LINK
                        </button>
                    </div>
                    <div id="loading-spinner" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 hidden"><div class="loader"></div></div>
                    <div id="error-overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-red-900 bg-opacity-95 hidden p-2 text-center z-30">
                        <p class="text-[10px] font-bold text-white">Error</p>
                        <p class="text-[8px] text-gray-200">Check Perms</p>
                    </div>
                </div>
                
                <!-- Shapes with labels -->
                <div class="w-full">
                    <label class="text-[9px] text-gray-500 mb-1 block uppercase tracking-wider text-center">Form</label>
                    <div class="flex justify-between gap-1 flex-wrap" id="shape-buttons">
                        <button class="option-btn active w-6 h-6 rounded bg-gradient-to-br from-blue-500 to-purple-500" data-shape="saturn" title="Saturn"></button>
                        <button class="option-btn w-6 h-6 rounded bg-gradient-to-br from-green-400 to-blue-500" data-shape="cube" title="Cube"></button>
                        <button class="option-btn w-6 h-6 rounded bg-gradient-to-br from-orange-500 to-amber-600" data-shape="sphere" title="Sphere"></button>
                        <button class="option-btn w-6 h-6 rounded bg-gradient-to-br from-pink-500 to-rose-500" data-shape="vortex" title="Vortex"></button>
                        <button class="option-btn w-6 h-6 rounded bg-gradient-to-br from-yellow-400 to-orange-500" data-shape="torus" title="Torus"></button>
                        <button class="option-btn w-6 h-6 rounded bg-gradient-to-br from-indigo-400 to-purple-600" data-shape="dna" title="DNA"></button>
                        <button class="option-btn w-6 h-6 rounded bg-gradient-to-br from-cyan-400 to-blue-600" data-shape="atom" title="Atom"></button>
                        <button class="option-btn w-6 h-6 rounded bg-gradient-to-br from-amber-300 to-orange-600" data-shape="hourglass" title="Hourglass"></button>
                    </div>
                    <div id="current-shape-label" class="text-[8px] text-center mt-1 text-purple-300 font-medium">Saturn</div>
                </div>

                <!-- Themes -->
                <div class="w-full">
                    <label class="text-[9px] text-gray-500 mb-1 block uppercase tracking-wider text-center">Energy</label>
                    <div class="flex items-center justify-center gap-2 overflow-x-auto pb-1" id="theme-container"></div>
                    <div id="current-theme-label" class="text-[8px] text-center mt-1 text-purple-300 font-medium">Cosmic</div>
                </div>
            </div>
        </div>

        <div class="flex justify-end pointer-events-none">
            <div class="glass-panel rounded-lg px-3 py-1.5 text-right opacity-80 scale-90 origin-bottom-right border-r-2 border-purple-500">
                <div class="text-[9px] text-purple-300 uppercase tracking-widest">Hand Tracking</div>
                <div class="text-sm font-mono text-white font-bold flex items-center justify-end gap-2">
                    <span id="zoom-val">100%</span> <span id="track-dot" class="w-1.5 h-1.5 bg-red-500 rounded-full"></span>
                </div>
            </div>
        </div>
    </div>

<script>
    // --- Constants (Magic numbers named) ---
    const CONSTANTS = {
        // Performance
        PARTICLE_COUNT_DESKTOP: 12000,
        PARTICLE_COUNT_MOBILE: 10000,
        STAR_COUNT_SMALL: 2000,
        STAR_COUNT_LARGE: 800,
        
        // Rendering - OPTIMIZED FOR RESPONSIVENESS
        BASE_SIZE: 18,
        ZOOM_SENSITIVITY: 4.0, // Increased for more responsive zoom
        BASE_HAND_SIZE: 0.2,
        FIST_THRESHOLD: 0.5,
        
        // RESPONSIVENESS OPTIMIZATION - Faster lerping
        ROTATION_LERP_SPEED: 0.25, // Increased from 0.15
        SCALE_LERP_SPEED: 0.3,    // Increased from 0.15
        SCATTER_LERP_SPEED: 0.35, // Increased from 0.4/0.05
        
        SHAPE_MORPH_SPEED: 0.15,
        
        // NEW: Adaptive smoothing for different gestures
        HISTORY_SIZE: 2,           // Reduced from 3 for less lag
        STABILITY_THRESHOLD: 0.008, // Reduced from 0.015 for more sensitivity
        
        // NEW: Velocity-based responsiveness
        VELOCITY_SMOOTHING: 0.7,   // How much velocity affects response
        MAX_VELOCITY: 0.3,         // Cap for velocity influence
        
        // Camera
        INITIAL_CAMERA_Z: 80,
        FOG_DENSITY: 0.008,
        
        // Zoom limits
        MIN_ZOOM: 0.2,
        MAX_ZOOM: 10.0,
        
        // Scene dimensions
        SCENE_BOUNDS: 1200,
        STARFIELD_BOUNDS_SMALL: 1200,
        STARFIELD_BOUNDS_LARGE: 800
    };

    // --- Config & Themes ---
    const THEMES = [
        { name: 'Cosmic', core: '#a855f7', ring: '#3b82f6' },
        { name: 'Aurora', core: '#10b981', ring: '#8b5cf6' },
        { name: 'Plasma', core: '#2563eb', ring: '#7c3aed' }
    ];
    
    let currentTheme = THEMES[0];
    let currentShape = 'saturn';
    let particleCount = window.innerWidth <= 768 ? CONSTANTS.PARTICLE_COUNT_MOBILE : CONSTANTS.PARTICLE_COUNT_DESKTOP;

    // --- State Management ---
    class AppState {
        constructor() {
            this.targetScale = 1;
            this.currentScale = 1;
            this.targetScatter = 0;
            this.currentScatter = 0;
            this.isExploded = false;
            this.rotY = 0;
            this.rotX = 0.2;
            this.targetRotY = 0;
            this.targetRotX = 0.2;
            this.handDetected = false;
            
            // NEW: Improved smoothing with velocity tracking
            this.xHistory = [];
            this.yHistory = [];
            this.lastStableX = 0.5;
            this.lastStableY = 0.5;
            this.velocityX = 0;
            this.velocityY = 0;
            this.lastUpdateTime = performance.now();
            
            // NEW: Exponential moving average for smooth values
            this.smoothX = 0.5;
            this.smoothY = 0.5;
            this.smoothZoom = 1;
            
            // NEW: Adaptive response curve
            this.lastRawX = 0.5;
            this.lastRawY = 0.5;
        }
        
        resetOnHandLoss() {
            this.handDetected = false;
            this.isExploded = false;
            this.targetScatter = 0;
            this.targetScale = 1;
            this.xHistory = [];
            this.yHistory = [];
            this.velocityX = 0;
            this.velocityY = 0;
            this.targetRotY = this.rotY;
            this.targetRotX = this.rotX * 0.9 + 0.2 * 0.1;
        }
        
        // NEW: Exponential moving average filter
        updateSmoothValues(rawX, rawY, zoom) {
            const alpha = 0.5; // Responsiveness factor
            this.smoothX = alpha * rawX + (1 - alpha) * this.smoothX;
            this.smoothY = alpha * rawY + (1 - alpha) * this.smoothY;
            this.smoothZoom = alpha * zoom + (1 - alpha) * this.smoothZoom;
        }
        
        // NEW: Calculate velocity for adaptive response
        calculateVelocity(currentX, currentY) {
            const now = performance.now();
            const deltaTime = Math.min((now - this.lastUpdateTime) / 1000, 0.1); // Cap deltaTime
            this.lastUpdateTime = now;
            
            if (deltaTime > 0) {
                const newVelocityX = (currentX - this.lastRawX) / deltaTime;
                const newVelocityY = (currentY - this.lastRawY) / deltaTime;
                
                // Smooth velocity changes
                this.velocityX = 0.3 * newVelocityX + 0.7 * this.velocityX;
                this.velocityY = 0.3 * newVelocityY + 0.7 * this.velocityY;
                
                // Cap velocity
                this.velocityX = Math.max(-CONSTANTS.MAX_VELOCITY, Math.min(CONSTANTS.MAX_VELOCITY, this.velocityX));
                this.velocityY = Math.max(-CONSTANTS.MAX_VELOCITY, Math.min(CONSTANTS.MAX_VELOCITY, this.velocityY));
            }
            
            this.lastRawX = currentX;
            this.lastRawY = currentY;
        }
        
        // NEW: Get adaptive lerp speed based on velocity
        getAdaptiveLerpSpeed(baseSpeed) {
            const velocityMagnitude = Math.sqrt(this.velocityX * this.velocityX + this.velocityY * this.velocityY);
            const velocityFactor = 1 + (velocityMagnitude / CONSTANTS.MAX_VELOCITY) * CONSTANTS.VELOCITY_SMOOTHING;
            return Math.min(baseSpeed * velocityFactor, baseSpeed * 2); // Cap at 2x
        }
    }

    const state = new AppState();

    // --- Resource Management ---
    class ResourceManager {
        constructor() {
            this.texture = null;
            this.resources = [];
        }
        
        createTexture() {
            if (this.texture) return this.texture;
            
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64;
            const cy = 64;
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.9)');
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#FFFFFF';
            ctx.fill();
            
            this.texture = new THREE.Texture(canvas);
            this.texture.needsUpdate = true;
            this.resources.push(this.texture);
            
            return this.texture;
        }
        
        dispose() {
            this.resources.forEach(resource => {
                if (resource.dispose) resource.dispose();
                if (resource.geometry) resource.geometry.dispose();
                if (resource.material) {
                    if (Array.isArray(resource.material)) {
                        resource.material.forEach(m => m.dispose());
                    } else {
                        resource.material.dispose();
                    }
                }
            });
            
            this.resources = [];
            this.texture = null;
        }
    }

    const resourceManager = new ResourceManager();

    // --- Three.js Scene Management ---
    class SceneManager {
        constructor() {
            this.container = document.getElementById('canvas-container');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.renderer = null;
            this.particleSystem = null;
            this.stars2 = null;
            this.init();
        }
        
        init() {
            this.scene.fog = new THREE.FogExp2(0x0a0518, CONSTANTS.FOG_DENSITY);
            
            this.camera.position.z = CONSTANTS.INITIAL_CAMERA_Z;
            this.camera.position.y = 0;
            this.camera.lookAt(0, 0, 0);
            
            this.renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                alpha: true, 
                powerPreference: "high-performance" 
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.container.appendChild(this.renderer.domElement);
            
            resourceManager.resources.push(this.scene, this.camera, this.renderer);
        }
        
        createStarfield() {
            // Small stars
            const starGeo1 = new THREE.BufferGeometry();
            const starPos1 = [];
            const starSizes1 = [];
            
            for(let i = 0; i < CONSTANTS.STAR_COUNT_SMALL; i++) {
                starPos1.push(
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_SMALL,
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_SMALL,
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_SMALL
                );
                starSizes1.push(Math.random() * 1.5);
            }
            
            starGeo1.setAttribute('position', new THREE.Float32BufferAttribute(starPos1, 3));
            starGeo1.setAttribute('size', new THREE.Float32BufferAttribute(starSizes1, 1));
            
            const starMat1 = new THREE.PointsMaterial({
                color: 0xa0a0ff,
                size: 1.0,
                map: resourceManager.createTexture(),
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            this.scene.add(new THREE.Points(starGeo1, starMat1));
            resourceManager.resources.push(starGeo1, starMat1);
            
            // Large stars
            const starGeo2 = new THREE.BufferGeometry();
            const starPos2 = [];
            const starSizes2 = [];
            
            for(let i = 0; i < CONSTANTS.STAR_COUNT_LARGE; i++) {
                starPos2.push(
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_LARGE,
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_LARGE,
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_LARGE
                );
                starSizes2.push(0.8 + Math.random() * 2.0);
            }
            
            starGeo2.setAttribute('position', new THREE.Float32BufferAttribute(starPos2, 3));
            starGeo2.setAttribute('size', new THREE.Float32BufferAttribute(starSizes2, 1));
            
            const starMat2 = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.0,
                map: resourceManager.createTexture(),
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            this.stars2 = new THREE.Points(starGeo2, starMat2);
            this.scene.add(this.stars2);
            resourceManager.resources.push(starGeo2, starMat2, this.stars2);
        }
        
        createParticleSystem() {
            const particlesGeometry = new THREE.BufferGeometry();
            const currentPositions = new Float32Array(particleCount * 3);
            const targetPositions = new Float32Array(particleCount * 3);
            const scatterVectors = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for(let i = 0; i < particleCount; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = 40 + Math.random() * 60;
                scatterVectors[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                scatterVectors[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                scatterVectors[i * 3 + 2] = r * Math.cos(phi);
                sizes[i] = 0.8 + Math.random() * 1.0;
            }
            
            const initData = ShapeGenerator.generate('saturn', particleCount, currentTheme);
            targetPositions.set(initData.pos);
            currentPositions.set(initData.pos.slice());
            colors.set(initData.col);
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 1.2,
                map: resourceManager.createTexture(),
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.NormalBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            this.particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            this.scene.add(this.particleSystem);
            
            this.particlesGeometry = particlesGeometry;
            this.particlesMaterial = particlesMaterial;
            this.currentPositions = currentPositions;
            this.targetPositions = targetPositions;
            this.scatterVectors = scatterVectors;
            this.colors = colors;
            
            resourceManager.resources.push(particlesGeometry, particlesMaterial, this.particleSystem);
            
            return {
                geometry: particlesGeometry,
                material: particlesMaterial,
                system: this.particleSystem,
                currentPositions,
                targetPositions,
                scatterVectors,
                colors
            };
        }
        
        resize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    // --- Shape Generation ---
    class ShapeGenerator {
        static generate(type, particleCount, theme) {
            const newPos = new Float32Array(particleCount * 3);
            const newCol = new Float32Array(particleCount * 3);
            const c1 = new THREE.Color(theme.core);
            const c2 = new THREE.Color(theme.ring);
            
            for(let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b;
                const ix = i * 3;
                
                switch(type) {
                    case 'saturn':
                        if (i < particleCount * 0.4) {
                            const phi = Math.acos(-1 + (2 * i) / (particleCount * 0.4));
                            const theta = Math.sqrt((particleCount * 0.4) * Math.PI) * phi;
                            const rad = CONSTANTS.BASE_SIZE + (Math.random() - 0.5);
                            x = rad * Math.cos(theta) * Math.sin(phi);
                            y = rad * Math.sin(theta) * Math.sin(phi);
                            z = rad * Math.cos(phi);
                            r = c1.r; g = c1.g; b = c1.b;
                        } else {
                            const rad = THREE.MathUtils.randFloat(26, 52);
                            const theta = Math.random() * Math.PI * 2;
                            x = rad * Math.cos(theta);
                            z = rad * Math.sin(theta);
                            y = (Math.random() - 0.5) * 0.5;
                            const mix = (rad - 26) / (52 - 26);
                            const c = new THREE.Color().lerpColors(c1, c2, mix);
                            r = c.r; g = c.g; b = c.b;
                        }
                        break;
                        
                    case 'cube':
                        const side = CONSTANTS.BASE_SIZE * 1.5;
                        const face = Math.floor(Math.random() * 6);
                        const u = (Math.random() - 0.5) * 2 * side;
                        const v = (Math.random() - 0.5) * 2 * side;
                        if(face === 0){x = side; y = u; z = v;}
                        else if(face === 1){x = -side; y = u; z = v;}
                        else if(face === 2){x = u; y = side; z = v;}
                        else if(face === 3){x = u; y = -side; z = v;}
                        else if(face === 4){x = u; y = v; z = side;}
                        else{x = u; y = v; z = -side;}
                        x += (Math.random() - 0.5);
                        y += (Math.random() - 0.5);
                        z += (Math.random() - 0.5);
                        const mix = Math.min((Math.abs(u) + Math.abs(v)) / (side * 2), 1);
                        const c = new THREE.Color().lerpColors(c1, c2, mix);
                        r = c.r; g = c.g; b = c.b;
                        break;
                        
                    case 'sphere':
                        const phi = Math.acos(-1 + (2 * i) / particleCount);
                        const theta = Math.sqrt(particleCount * Math.PI) * phi;
                        const rad = CONSTANTS.BASE_SIZE * 1.5;
                        x = rad * Math.cos(theta) * Math.sin(phi);
                        y = rad * Math.sin(theta) * Math.sin(phi);
                        z = rad * Math.cos(phi);
                        const sphereColor = new THREE.Color().lerpColors(c1, c2, Math.abs(y / rad));
                        r = sphereColor.r; g = sphereColor.g; b = sphereColor.b;
                        break;
                        
                    case 'vortex':
                        const branchAngle = (i % 3) * ((2 * Math.PI) / 3);
                        const radVortex = Math.random() * 50;
                        const angle = branchAngle + radVortex * 0.1;
                        x = Math.cos(angle) * radVortex;
                        z = Math.sin(angle) * radVortex;
                        y = (Math.random() - 0.5) * (10 - radVortex * 0.15);
                        const vortexColor = new THREE.Color().lerpColors(c1, c2, radVortex / 50);
                        r = vortexColor.r; g = vortexColor.g; b = vortexColor.b;
                        break;
                        
                    case 'torus':
                        const uTorus = Math.random() * Math.PI * 2;
                        const vTorus = Math.random() * Math.PI * 2;
                        x = (30 + 10 * Math.cos(vTorus)) * Math.cos(uTorus);
                        z = (30 + 10 * Math.cos(vTorus)) * Math.sin(uTorus);
                        y = 10 * Math.sin(vTorus);
                        const torusColor = new THREE.Color().lerpColors(c1, c2, Math.abs(Math.sin(uTorus * 2)));
                        r = torusColor.r; g = torusColor.g; b = torusColor.b;
                        break;
                        
                    case 'dna':
                        const h = (i / particleCount) * 80 - 40;
                        const angleDNA = h * 0.2;
                        const radDNA = 12;
                        const offset = (i % 2 === 0) ? 0 : Math.PI;
                        x = Math.cos(angleDNA + offset) * radDNA + (Math.random() - 0.5) * 2;
                        z = Math.sin(angleDNA + offset) * radDNA + (Math.random() - 0.5) * 2;
                        y = h;
                        const dnaColor = (i % 2 === 0) ? c1 : c2;
                        r = dnaColor.r; g = dnaColor.g; b = dnaColor.b;
                        break;
                        
                    case 'atom':
                        if(i < particleCount * 0.2) {
                            const phiAtom = Math.acos(-1 + (2 * i) / (particleCount * 0.2));
                            const thetaAtom = Math.sqrt((particleCount * 0.2) * Math.PI) * phiAtom;
                            const radAtom = CONSTANTS.BASE_SIZE * 0.4 + (Math.random() - 0.5);
                            x = radAtom * Math.cos(thetaAtom) * Math.sin(phiAtom);
                            y = radAtom * Math.sin(thetaAtom) * Math.sin(phiAtom);
                            z = radAtom * Math.cos(phiAtom);
                            r = c1.r; g = c1.g; b = c1.b;
                        } else {
                            const ringPart = (i - particleCount * 0.2);
                            const ringTotal = particleCount * 0.8;
                            const ringIndex = Math.floor(ringPart / (ringTotal / 3));
                            const rad = CONSTANTS.BASE_SIZE * 3.0;
                            const theta = Math.random() * Math.PI * 2;
                            const rt = (Math.random() - 0.5) * 1.5;
                            if(ringIndex === 0){
                                x = rad * Math.cos(theta);
                                y = rad * Math.sin(theta);
                                z = rt;
                                const rot = Math.PI / 3;
                                const yn = y * Math.cos(rot) - z * Math.sin(rot);
                                const zn = y * Math.sin(rot) + z * Math.cos(rot);
                                y = yn;
                                z = zn;
                            } else if(ringIndex === 1){
                                x = rad * Math.cos(theta);
                                y = rad * Math.sin(theta);
                                z = rt;
                                const rot = -Math.PI / 3;
                                const yn = y * Math.cos(rot) - z * Math.sin(rot);
                                const zn = y * Math.sin(rot) + z * Math.cos(rot);
                                y = yn;
                                z = zn;
                            } else {
                                x = rad * Math.cos(theta);
                                z = rad * Math.sin(theta);
                                y = rt;
                            }
                            const atomColor = new THREE.Color().lerpColors(c1, c2, Math.random() * 0.5 + 0.5);
                            r = atomColor.r; g = atomColor.g; b = atomColor.b;
                        }
                        break;
                        
                    case 'hourglass':
                        const half = particleCount / 2;
                        const hHour = CONSTANTS.BASE_SIZE * 3;
                        const w = CONSTANTS.BASE_SIZE * 2.5;
                        let nh, radHour;
                        if(i < half){
                            nh = i / half;
                            y = nh * hHour + 1;
                            radHour = nh * w;
                        } else {
                            nh = (i - half) / half;
                            y = -nh * hHour - 1;
                            radHour = nh * w;
                        }
                        radHour = Math.pow(radHour / w, 1.5) * w;
                        const thetaHour = Math.random() * Math.PI * 2;
                        x = radHour * Math.cos(thetaHour);
                        z = radHour * Math.sin(thetaHour);
                        if(Math.random() > 0.97){
                            x = (Math.random() - 0.5) * 2;
                            z = (Math.random() - 0.5) * 2;
                            y = (Math.random() - 0.5) * hHour * 2;
                        }
                        const hourglassColor = new THREE.Color().lerpColors(c1, c2, radHour / w);
                        r = hourglassColor.r; g = hourglassColor.g; b = hourglassColor.b;
                        break;
                        
                    default:
                        x = y = z = r = g = b = 0;
                }
                
                newPos[ix] = x;
                newPos[ix + 1] = y;
                newPos[ix + 2] = z;
                newCol[ix] = r;
                newCol[ix + 1] = g;
                newCol[ix + 2] = b;
            }
            
            return { pos: newPos, col: newCol };
        }
    }

    // --- UI Management ---
    class UIManager {
        constructor() {
            this.themeContainer = document.getElementById('theme-container');
            this.shapeButtons = document.getElementById('shape-buttons');
            this.currentShapeLabel = document.getElementById('current-shape-label');
            this.currentThemeLabel = document.getElementById('current-theme-label');
            this.zoomVal = document.getElementById('zoom-val');
            this.trackDot = document.getElementById('track-dot');
            this.scatterText = document.getElementById('scatter-text');
            this.loader = document.getElementById('loading-spinner');
            this.startBtn = document.getElementById('start-btn');
            this.startOverlay = document.getElementById('start-overlay');
            this.statusText = document.getElementById('status-text');
            this.statusIndicator = document.getElementById('status-indicator');
            
            this.init();
        }
        
        init() {
            this.initThemeButtons();
            this.initShapeButtons();
        }
        
        initThemeButtons() {
            THEMES.forEach((theme, index) => {
                const btn = document.createElement('div');
                btn.className = `w-6 h-6 rounded-full cursor-pointer border-2 border-white/20 transition-all ${index === 0 ? 'scale-110 border-white shadow-lg' : ''}`;
                btn.style.background = `linear-gradient(135deg, ${theme.core} 0%, ${theme.ring} 100%)`;
                btn.dataset.theme = theme.name.toLowerCase();
                btn.onclick = () => this.setTheme(theme, btn);
                this.themeContainer.appendChild(btn);
            });
        }
        
        initShapeButtons() {
            const buttons = this.shapeButtons.querySelectorAll('.option-btn');
            buttons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const shape = btn.dataset.shape;
                    this.setShape(shape, btn);
                });
            });
        }
        
        setTheme(theme, button) {
            currentTheme = theme;
            document.querySelectorAll('#theme-container div').forEach(b => {
                b.classList.remove('scale-110', 'border-white', 'shadow-lg');
            });
            button.classList.add('scale-110', 'border-white', 'shadow-lg');
            this.currentThemeLabel.textContent = theme.name;
            
            if (sceneManager.particleSystem) {
                updateShapeData();
            }
        }
        
        setShape(shape, button) {
            currentShape = shape;
            document.querySelectorAll('.option-btn').forEach(b => b.classList.remove('active'));
            button.classList.add('active');
            this.currentShapeLabel.textContent = button.title || shape.charAt(0).toUpperCase() + shape.slice(1);
            
            if (sceneManager.particleSystem) {
                updateShapeData();
            }
        }
        
        updateTracking(status, zoom = null) {
            if (status === 'tracking') {
                this.trackDot.classList.replace('bg-red-500', 'bg-green-500');
                this.trackDot.classList.add('animate-pulse');
            } else {
                this.trackDot.classList.replace('bg-green-500', 'bg-red-500');
                this.trackDot.classList.remove('animate-pulse');
            }
            
            if (zoom !== null) {
                this.zoomVal.textContent = Math.round(zoom * 100) + "%";
            }
        }
        
        updateStatus(status, isError = false) {
            this.statusText.textContent = status;
            if (isError) {
                this.statusIndicator.classList.replace('bg-yellow-400', 'bg-red-400');
            } else if (status === "Connected") {
                this.statusIndicator.classList.replace('bg-yellow-400', 'bg-green-400');
                this.statusIndicator.classList.remove('animate-pulse');
            }
        }
    }

    // --- Hand Tracking - OPTIMIZED FOR RESPONSIVENESS ---
    class HandTracker {
        constructor() {
            this.videoElement = document.getElementsByClassName('input_video')[0];
            this.canvasElement = document.getElementsByClassName('output_canvas')[0];
            this.canvasCtx = this.canvasElement.getContext('2d');
            this.hands = null;
            this.cameraUtils = null;
            this.ui = null;
            
            // NEW: Cached values for performance
            this.lastLandmarkTime = 0;
            this.frameCount = 0;
            
            this.init();
        }
        
        init() {
            this.hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            // OPTIMIZED: Lower confidence for faster response
            this.hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // Reduced from 1 for faster processing
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.3  // Reduced from 0.5 for less stutter
            });
            
            this.hands.onResults(this.onResults.bind(this));
            
            this.cameraUtils = new Camera(this.videoElement, {
                onFrame: async () => {
                    await this.hands.send({ image: this.videoElement });
                },
                width: 240,  // Reduced from 320 for faster processing
                height: 180  // Reduced from 240
            });
        }
        
        // NEW: Low-pass filter for smooth values without lag
        lowPassFilter(newValue, oldValue, alpha = 0.6) {
            return alpha * newValue + (1 - alpha) * oldValue;
        }
        
        // NEW: Improved weighted average with exponential weighting
        getWeightedAverageExponential(history) {
            if(history.length === 0) return 0.5;
            let sum = 0, weightSum = 0;
            const base = 1.5; // Exponential weighting
            for(let i = 0; i < history.length; i++) {
                const w = Math.pow(base, i); // More weight to recent values
                sum += history[i] * w;
                weightSum += w;
            }
            return sum / weightSum;
        }
        
        onResults(results) {
            this.frameCount++;
            
            // Only process every other frame for better performance
            if (this.frameCount % 2 !== 0) return;
            
            if (uiManager.loader.style.display !== 'none') {
                uiManager.loader.style.display = 'none';
                uiManager.updateStatus("Connected");
            }
            
            this.canvasElement.width = results.image.width;
            this.canvasElement.height = results.image.height;
            
            this.canvasCtx.save();
            this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
            this.canvasCtx.drawImage(results.image, 0, 0, this.canvasElement.width, this.canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                state.handDetected = true;
                uiManager.updateTracking('tracking');
                
                // Draw hand landmarks
                drawConnectors(this.canvasCtx, landmarks, HAND_CONNECTIONS, {color: 'rgba(168, 85, 247, 0.5)', lineWidth: 2});
                drawLandmarks(this.canvasCtx, landmarks, {color: '#FFFFFF', lineWidth: 1, radius: 2});
                
                // Calculate zoom with improved response curve
                const wrist = landmarks[0];
                const midMCP = landmarks[9];
                const handSize = Math.hypot(wrist.x - midMCP.x, wrist.y - midMCP.y);
                
                // NEW: Exponential response curve for zoom (more control at smaller sizes)
                let zoom = Math.pow(handSize / CONSTANTS.BASE_HAND_SIZE, 1.2);
                zoom = Math.max(CONSTANTS.MIN_ZOOM, Math.min(zoom, CONSTANTS.MAX_ZOOM));
                
                // Update smooth values
                state.updateSmoothValues(landmarks[9].x, landmarks[9].y, zoom);
                
                // Use smooth values for immediate response
                state.targetScale = state.smoothZoom;
                state.calculateVelocity(landmarks[9].x, landmarks[9].y);
                
                uiManager.updateTracking('tracking', state.targetScale);
                
                // Calculate gesture openness
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const openness = pinchDist / handSize;
                
                // Gesture logic - OPTIMIZED for faster response
                if (openness < CONSTANTS.FIST_THRESHOLD) {
                    // Fist detected: Trigger automatic scatter
                    state.isExploded = true;
                    state.targetScatter = 1.0;
                    if(uiManager.scatterText) uiManager.scatterText.style.opacity = 1;
                } else {
                    // Not a fist
                    if (state.isExploded) {
                        // IF exploded previously, now control re-assembly via hand opening
                        const range = 0.6;
                        let val = (openness - CONSTANTS.FIST_THRESHOLD) / range;
                        val = Math.max(0, Math.min(1, val));
                        
                        // NEW: Cubic easing for more natural feel
                        val = val * val * (3 - 2 * val);
                        state.targetScatter = 1.0 - val;
                        
                        // Reset latch if fully assembled
                        if (state.targetScatter < 0.05) {
                            state.isExploded = false;
                            state.targetScatter = 0.0;
                        }
                    } else {
                        // Not exploded, not a fist: Force solid
                        state.targetScatter = 0.0;
                        if(uiManager.scatterText) uiManager.scatterText.style.opacity = 0;
                    }
                }
                
                // NEW: Simplified smoothing with velocity-based adaptation
                state.xHistory.push(landmarks[9].x);
                state.yHistory.push(landmarks[9].y);
                if(state.xHistory.length > CONSTANTS.HISTORY_SIZE) state.xHistory.shift();
                if(state.yHistory.length > CONSTANTS.HISTORY_SIZE) state.yHistory.shift();
                
                // Use exponential weighted average for smoother movement
                const smoothedX = this.getWeightedAverageExponential(state.xHistory);
                const smoothedY = this.getWeightedAverageExponential(state.yHistory);
                
                const deltaX = Math.abs(smoothedX - state.lastStableX);
                const deltaY = Math.abs(smoothedY - state.lastStableY);
                
                // NEW: Dynamic threshold based on velocity
                const dynamicThreshold = CONSTANTS.STABILITY_THRESHOLD * 
                    (1 + Math.min(Math.abs(state.velocityX) + Math.abs(state.velocityY), 0.2));
                
                if (deltaX > dynamicThreshold) {
                    state.lastStableX = smoothedX;
                }
                if (deltaY > dynamicThreshold) {
                    state.lastStableY = smoothedY;
                }
                
                // NEW: Direct mapping with velocity boost for more responsive control
                const x = state.lastStableX;
                const y = state.lastStableY;
                
                // Apply velocity to rotation for more responsive feel
                const velocityBoost = 0.5;
                state.targetRotY = (0.5 - x) * 4.0 + state.velocityX * velocityBoost;
                state.targetRotX = (0.5 - y) * 4.0 + state.velocityY * velocityBoost;
                
                // NEW: Cap rotation speed for control
                state.targetRotY = Math.max(-6, Math.min(6, state.targetRotY));
                state.targetRotX = Math.max(-6, Math.min(6, state.targetRotX));
                
            } else {
                state.resetOnHandLoss();
                uiManager.updateTracking('lost');
                if(uiManager.scatterText) uiManager.scatterText.style.opacity = 0;
                state.targetRotY += 0.002;
                state.targetRotX = state.rotX * 0.9 + 0.2 * 0.1;
            }
            
            this.canvasCtx.restore();
        }
        
        start() {
            this.cameraUtils.start();
        }
        
        stop() {
            if (this.cameraUtils) {
                this.cameraUtils.stop();
            }
        }
    }

    // --- Global Variables ---
    let sceneManager;
    let handTracker;
    let uiManager;
    let animationId;
    const clock = new THREE.Clock();

    // --- Helper Functions ---
    function updateShapeData() {
        const data = ShapeGenerator.generate(currentShape, particleCount, currentTheme);
        for(let i = 0; i < data.pos.length; i++) {
            sceneManager.targetPositions[i] = data.pos[i];
            sceneManager.colors[i] = data.col[i];
        }
        sceneManager.particlesGeometry.attributes.color.needsUpdate = true;
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        // NEW: Adaptive lerp speeds based on velocity
        const rotationLerpSpeed = state.getAdaptiveLerpSpeed(CONSTANTS.ROTATION_LERP_SPEED);
        const scaleLerpSpeed = state.getAdaptiveLerpSpeed(CONSTANTS.SCALE_LERP_SPEED);
        const scatterLerpSpeed = state.getAdaptiveLerpSpeed(CONSTANTS.SCATTER_LERP_SPEED);
        
        // Update scale with adaptive speed
        state.currentScale += (state.targetScale - state.currentScale) * scaleLerpSpeed;
        
        // Update scatter animation with adaptive speed
        if (state.isExploded && state.targetScatter > 0.9) {
            state.currentScatter += (state.targetScatter - state.currentScatter) * (scatterLerpSpeed * 0.5);
        } else {
            state.currentScatter += (state.targetScatter - state.currentScatter) * scatterLerpSpeed;
        }
        
        // Update rotation with adaptive speed
        if (state.handDetected) {
            state.rotY += (state.targetRotY - state.rotY) * rotationLerpSpeed;
            state.rotX += (state.targetRotX - state.rotX) * rotationLerpSpeed;
        } else {
            state.rotY += 0.002;
            state.rotX += (state.targetRotX - state.rotX) * 0.05;
        }
        
        // Update particle system
        sceneManager.particleSystem.rotation.y = state.rotY;
        sceneManager.particleSystem.rotation.x = state.rotX;
        sceneManager.particleSystem.scale.set(state.currentScale, state.currentScale, state.currentScale);
        sceneManager.particlesMaterial.size = 1.2 + Math.log(Math.max(1, state.currentScale)) * 0.5;
        
        // Update stars rotation
        if (sceneManager.stars2) {
            sceneManager.stars2.rotation.y = time * 0.02;
        }
        
        // Update particle positions
        const posAttr = sceneManager.particlesGeometry.attributes.position;
        for(let i = 0; i < particleCount; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;
            
            let cx = sceneManager.currentPositions[ix];
            let cy = sceneManager.currentPositions[iy];
            let cz = sceneManager.currentPositions[iz];
            
            const tx = sceneManager.targetPositions[ix];
            const ty = sceneManager.targetPositions[iy];
            const tz = sceneManager.targetPositions[iz];
            
            cx += (tx - cx) * CONSTANTS.SHAPE_MORPH_SPEED;
            cy += (ty - cy) * CONSTANTS.SHAPE_MORPH_SPEED;
            cz += (tz - cz) * CONSTANTS.SHAPE_MORPH_SPEED;
            
            sceneManager.currentPositions[ix] = cx;
            sceneManager.currentPositions[iy] = cy;
            sceneManager.currentPositions[iz] = cz;
            
            const sx = sceneManager.scatterVectors[ix];
            const sy = sceneManager.scatterVectors[iy];
            const sz = sceneManager.scatterVectors[iz];
            
            const fx = cx + (sx - cx) * state.currentScatter;
            const fy = cy + (sy - cy) * state.currentScatter;
            const fz = cz + (sz - cz) * state.currentScatter;
            
            let noise = 0;
            if (state.currentScatter < 0.1) {
                noise = Math.sin(time * 2 + i) * 0.05;
            }
            
            posAttr.setXYZ(i, fx + noise, fy + noise, fz + noise);
        }
        
        posAttr.needsUpdate = true;
        sceneManager.renderer.render(sceneManager.scene, sceneManager.camera);
    }

    function startApp() {
        // Initialize managers
        sceneManager = new SceneManager();
        uiManager = new UIManager();
        handTracker = new HandTracker();
        
        // Create scene
        sceneManager.createStarfield();
        sceneManager.createParticleSystem();
        
        // Start animation
        animate();
        
        // Set up event listeners
        setupEventListeners();
    }

    function setupEventListeners() {
        // Start button
        uiManager.startBtn.onclick = () => {
            uiManager.startOverlay.style.display = 'none';
            uiManager.loader.style.display = 'flex';
            
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } })
                .then(stream => {
                    // Stop any existing tracks
                    stream.getTracks().forEach(track => track.stop());
                    handTracker.start();
                })
                .catch(error => {
                    console.error('Camera error:', error);
                    uiManager.loader.style.display = 'none';
                    uiManager.updateStatus('Error', true);
                    document.getElementById('error-overlay').style.display = 'flex';
                });
        };
        
        // Window resize
        window.addEventListener('resize', () => {
            sceneManager.resize();
        });
        
        // Page cleanup
        window.addEventListener('beforeunload', cleanup);
        window.addEventListener('pagehide', cleanup);
    }

    function cleanup() {
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        
        if (handTracker) {
            handTracker.stop();
        }
        
        resourceManager.dispose();
        
        if (handTracker && handTracker.videoElement && handTracker.videoElement.srcObject) {
            const stream = handTracker.videoElement.srcObject;
            const tracks = stream.getTracks();
            tracks.forEach(track => track.stop());
        }
    }

    // --- Initialize Application ---
    document.addEventListener('DOMContentLoaded', () => {
        try {
            startApp();
        } catch (error) {
            console.error('Failed to initialize app:', error);
            uiManager.updateStatus('Init Failed', true);
        }
    });
</script>
</body>
</html>
