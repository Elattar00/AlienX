<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gesture Controlled Saturn Particles</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        /* Prevent pull-to-refresh and scrolling on mobile */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Inter', sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(20, 20, 30, 0.65);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .interactive-element {
            pointer-events: auto;
        }

        /* Mobile Camera Handling */
        .input_video { 
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 1px;
            height: 1px;
            pointer-events: none;
            z-index: -1;
        }

        /* Mirror the canvas for selfie-mode feel */
        .mirrored-output {
            transform: scaleX(-1);
        }
        
        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 3px solid #60a5fa;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Pulse animation for start button */
        @keyframes scanner {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
        }
        .btn-pulse {
            animation: scanner 2s infinite;
        }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-4 md:p-6 safe-area-inset">
        
        <!-- Top Section -->
        <div class="flex flex-col md:flex-row justify-between items-start gap-4">
            
            <!-- Title Card -->
            <div class="glass-panel rounded-2xl p-4 text-white w-full md:w-auto md:max-w-xs interactive-element transition-all">
                <div class="flex justify-between items-center mb-2">
                    <h1 class="text-lg md:text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-300 to-purple-400">
                        Aether Saturn
                    </h1>
                    <div class="flex items-center text-[10px] md:text-xs bg-black bg-opacity-30 rounded-full px-2 py-1">
                        <span id="status-indicator" class="w-1.5 h-1.5 rounded-full bg-yellow-400 mr-2 animate-pulse"></span>
                        <span id="status-text">Standby</span>
                    </div>
                </div>
                
                <div class="text-[11px] md:text-xs text-gray-300 space-y-1 font-medium">
                    <p class="flex items-center"><span class="mr-2 opacity-70">ü§è</span> Pinch to Shrink / Expand</p>
                    <p class="flex items-center"><span class="mr-2 opacity-70">üëã</span> Move Hand to Rotate</p>
                </div>
            </div>

            <!-- Camera & Controls -->
            <div class="glass-panel rounded-2xl p-2 flex flex-row md:flex-col items-center gap-3 interactive-element">
                <!-- Camera Preview Container -->
                <div class="relative w-28 h-20 md:w-36 md:h-28 bg-black rounded-xl overflow-hidden border border-gray-600 shadow-2xl shrink-0">
                    <video class="input_video" playsinline webkit-playsinline></video>
                    
                    <!-- Mirrored Canvas for Selfie Mode -->
                    <canvas class="output_canvas mirrored-output absolute top-0 left-0 w-full h-full object-cover"></canvas>
                    
                    <!-- Start Button Overlay -->
                    <div id="start-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 z-20 cursor-pointer backdrop-blur-[2px]">
                        <button id="start-btn" class="btn-pulse bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-bold py-1.5 px-4 rounded-full transition border border-blue-400">
                            TAP TO START
                        </button>
                    </div>

                    <div id="loading-spinner" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 hidden">
                        <div class="loader"></div>
                    </div>
                    
                    <!-- Error Overlay -->
                    <div id="error-overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-red-900 bg-opacity-95 hidden p-2 text-center z-30">
                        <p id="error-title" class="text-[10px] font-bold text-white mb-1">Error</p>
                        <p id="error-desc" class="text-[8px] text-gray-200 leading-tight">Check permissions.</p>
                    </div>
                </div>
                
                <!-- Color Picker (Compact for Mobile) -->
                <div class="flex flex-col justify-center w-full px-1">
                    <label class="text-[9px] text-gray-400 mb-1 hidden md:block">Atmosphere</label>
                    <div class="flex items-center justify-between md:justify-start gap-2">
                        <input type="color" id="color-picker" value="#4aa8ff" class="w-8 h-8 rounded-full cursor-pointer border-2 border-white border-opacity-20 bg-transparent p-0 overflow-hidden">
                        <span class="text-[10px] text-gray-400 font-mono md:inline hidden" id="color-hex">#4aa8ff</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer Stats -->
        <div class="flex justify-end pointer-events-none">
            <div class="glass-panel rounded-lg px-3 py-1.5 text-right opacity-80 scale-90 origin-bottom-right">
                <div class="text-[9px] text-gray-400 uppercase tracking-widest">Particles</div>
                <div class="text-sm font-mono text-white font-bold">12,000</div>
            </div>
        </div>
    </div>

<script>
    // --- Mobile Optimization Config ---
    const CONFIG = {
        particleCount: 12000, 
        sphereRadius: 18,
        ringInner: 24,
        ringOuter: 48,
        baseColor: 0x4aa8ff,
        lerpFactor: 0.4, // HIGH value for Instant/Real-Time response
        deadZone: 0.02,   // Very small deadzone for immediate reaction
    };

    // --- State Management ---
    const state = {
        targetScale: 1,
        currentScale: 1,
        targetRotationY: 0,
        currentRotationY: 0,
        targetRotationX: 0.2, 
        currentRotationX: 0.2,
        handDetected: false,
        // History arrays removed for real-time input
    };

    // --- Three.js Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.008);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 80;
    camera.position.y = 20;
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    container.appendChild(renderer.domElement);

    // --- Particle System ---
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = [];
    const originalPositions = []; 
    const randomness = []; 

    // Generate Sphere
    for (let i = 0; i < CONFIG.particleCount * 0.4; i++) {
        const phi = Math.acos(-1 + (2 * i) / (CONFIG.particleCount * 0.4));
        const theta = Math.sqrt((CONFIG.particleCount * 0.4) * Math.PI) * phi;
        const r = CONFIG.sphereRadius + (Math.random() - 0.5) * 1.5; 
        
        const x = r * Math.cos(theta) * Math.sin(phi);
        const y = r * Math.sin(theta) * Math.sin(phi);
        const z = r * Math.cos(phi);

        positions.push(x, y, z);
        originalPositions.push(x, y, z);
        randomness.push(Math.random(), Math.random(), Math.random());
    }

    // Generate Rings
    const ringCount = CONFIG.particleCount * 0.6;
    for (let i = 0; i < ringCount; i++) {
        const r = THREE.MathUtils.randFloat(CONFIG.ringInner, CONFIG.ringOuter);
        const theta = Math.random() * Math.PI * 2;
        
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        const y = (Math.random() - 0.5) * 1.2; 

        positions.push(x, y, z);
        originalPositions.push(x, y, z);
        randomness.push(Math.random(), Math.random(), Math.random());
    }

    particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randomness, 3));

    const particlesMaterial = new THREE.PointsMaterial({
        color: CONFIG.baseColor,
        size: window.devicePixelRatio > 1 ? 0.9 : 0.6, 
        transparent: true,
        opacity: 0.85,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
    });

    const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particleSystem);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // --- Logic Helpers ---

    const colorPicker = document.getElementById('color-picker');
    colorPicker.addEventListener('input', (e) => {
        particlesMaterial.color = new THREE.Color(e.target.value);
    });

    // --- MediaPipe & Camera ---
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    const statusText = document.getElementById('status-text');
    const statusInd = document.getElementById('status-indicator');
    const loader = document.getElementById('loading-spinner');
    const startBtn = document.getElementById('start-btn');
    const startOverlay = document.getElementById('start-overlay');
    const errorOverlay = document.getElementById('error-overlay');
    const errorTitle = document.getElementById('error-title');
    const errorDesc = document.getElementById('error-desc');

    function onResults(results) {
        if (loader.style.display !== 'none') {
            loader.style.display = 'none';
            statusText.textContent = "Tracking Active";
            statusInd.classList.replace('bg-yellow-400', 'bg-green-400');
        }

        canvasElement.width = results.image.width;
        canvasElement.height = results.image.height;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            state.handDetected = true;

            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#60a5fa', lineWidth: 3});
            drawLandmarks(canvasCtx, landmarks, {color: '#f472b6', lineWidth: 1, radius: 3});

            // 1. DIRECT RAW INPUT (Real-time, no history smoothing)
            const rawX = landmarks[9].x;
            const rawY = landmarks[9].y;

            // 2. LOGIC (MIRRORED SELFIE MODE)
            // Camera is Standard (Object on Left = x~0).
            // CSS mirrors it visually (Object appears on Right).
            // We want "Hand on Screen Right" -> "Rotate Right".
            // Screen Right corresponds to Camera Left (x ~ 0).
            // Formula: (Center - x) = (0.5 - 0.1) = +0.4 (Right Turn).
            
            let xOffsetRaw = 0.5 - rawX; 
            let xOffsetApplied = 0;

            // Dead Zone
            if (Math.abs(xOffsetRaw) > CONFIG.deadZone) {
                const sign = Math.sign(xOffsetRaw);
                xOffsetApplied = xOffsetRaw - (sign * CONFIG.deadZone);
                const rangeScale = 0.5 / (0.5 - CONFIG.deadZone); 
                xOffsetApplied *= rangeScale;
            }

            // Non-linear Sensitivity - Fast Response
            state.targetRotationY = Math.sign(xOffsetApplied) * Math.pow(Math.abs(xOffsetApplied), 1.2) * 6.0;

            // Vertical Tilt (Inverted for natural "pull" feel)
            const yOffsetRaw = 0.5 - rawY;
            let yOffsetApplied = 0;
            if (Math.abs(yOffsetRaw) > CONFIG.deadZone) {
                const sign = Math.sign(yOffsetRaw);
                yOffsetApplied = yOffsetRaw - (sign * CONFIG.deadZone);
                yOffsetApplied *= (0.5 / (0.5 - CONFIG.deadZone));
            }
            state.targetRotationX = yOffsetApplied * 5.0;

            // 3. PINCH SCALE
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const wrist = landmarks[0];
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const scaleRef = Math.hypot(wrist.x - landmarks[5].x, wrist.y - landmarks[5].y);
            
            const normalizedOpenness = pinchDist / scaleRef;
            let expansion = (normalizedOpenness - 0.25) * 2.5; 
            
            if (expansion < 0.15) expansion = 0.15; 
            if (expansion > 3.5) expansion = 3.5;
            
            state.targetScale = expansion;

        } else {
            state.handDetected = false;
            state.targetScale = 1;
            
            // Idle Drift
            state.targetRotationY += 0.002;
            state.targetRotationX = state.currentRotationX * 0.95 + 0.2 * 0.05; 
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1, 
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320, 
        height: 240
    });
    
    // --- Mobile Start Interaction ---
    startBtn.addEventListener('click', () => {
        if (window.location.protocol === 'file:') {
            showError("Security Error", "Cannot run on local file system (file://). Please use a local server or GitHub Pages.");
            return;
        }

        startOverlay.style.display = 'none';
        loader.style.display = 'flex';
        statusText.textContent = "Requesting Cam...";
        
        // Mobile-friendly camera request
        navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: 'user', // Prefer front camera
                width: { ideal: 320 },
                height: { ideal: 240 }
            } 
        }).then(stream => {
            stream.getTracks().forEach(track => track.stop()); 
            statusText.textContent = "Loading AI...";
            cameraUtils.start().catch(handleCameraError);
        }).catch(handleCameraError);
    });

    function handleCameraError(err) {
        console.error(err);
        loader.style.display = 'none';
        
        let title = "Camera Error";
        let msg = "Unknown error occurred.";

        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            title = "Permission Denied";
            msg = "Access blocked. Tap 'AA' or Lock icon in URL bar to allow camera.";
        } else if (err.name === 'NotFoundError') {
            title = "No Camera";
            msg = "No front camera found.";
        }
        
        showError(title, msg);
    }

    function showError(title, msg) {
        errorTitle.textContent = title;
        errorDesc.textContent = msg;
        errorOverlay.style.display = 'flex';
        statusText.textContent = "Failed";
        statusInd.classList.replace('bg-yellow-400', 'bg-red-500');
    }

    // --- Animation Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();

        // High Speed State Updates
        state.currentScale += (state.targetScale - state.currentScale) * CONFIG.lerpFactor;
        
        if (state.handDetected) {
            state.currentRotationY += (state.targetRotationY - state.currentRotationY) * CONFIG.lerpFactor;
            state.currentRotationX += (state.targetRotationX - state.currentRotationX) * CONFIG.lerpFactor;
        } else {
            state.currentRotationY += 0.003; 
            state.currentRotationX += (state.targetRotationX - state.currentRotationX) * 0.05;
        }

        // Apply Transforms
        particleSystem.rotation.y = state.currentRotationY;
        particleSystem.rotation.x = state.currentRotationX;
        particleSystem.rotation.z = Math.cos(time * 0.15) * 0.08;

        // Update Particles
        const positionsAttribute = particlesGeometry.attributes.position;
        const positionsArray = positionsAttribute.array;

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            const ox = originalPositions[ix];
            const oy = originalPositions[iy];
            const oz = originalPositions[iz];

            let px = ox * state.currentScale;
            let py = oy * state.currentScale;
            let pz = oz * state.currentScale;

            // Organic Wave Movement
            const noise = Math.sin(time * 1.5 + i * 0.05) * 0.3 * state.currentScale;
            
            if (i > CONFIG.particleCount * 0.4) {
                 // Ring Drift
                 const drift = Math.sin(time * 0.5 + i) * 0.15;
                 px += drift;
                 pz += Math.cos(time * 0.5 + i) * 0.15;
            } else {
                // Sphere Pulse
                px += noise;
                py += noise;
                pz += noise;
            }

            positionsArray[ix] = px;
            positionsArray[iy] = py;
            positionsArray[iz] = pz;
        }

        positionsAttribute.needsUpdate = true;
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
