<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Saturn Particles</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        
        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
        }

        .interactive-element {
            pointer-events: auto;
        }

        /* FIX FOR MOBILE: 
           Do not use display: none for video elements on mobile.
           Use opacity: 0 and absolute positioning instead.
           Browsers pause hidden videos to save battery.
        */
        .input_video { 
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 1px;
            height: 1px;
            pointer-events: none;
            z-index: -1;
        }
        
        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 3px solid #3b82f6;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-6">
        
        <!-- Header / Status -->
        <div class="flex justify-between items-start">
            <div class="glass-panel rounded-xl p-4 text-white max-w-sm interactive-element transition-all hover:bg-opacity-70">
                <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">
                    Aether Saturn
                </h1>
                <p class="text-xs text-gray-300 mt-1">Real-time Gesture Particle System</p>
                
                <div class="mt-4 space-y-2">
                    <div class="flex items-center text-sm">
                        <span id="status-indicator" class="w-2 h-2 rounded-full bg-yellow-500 mr-2 animate-pulse"></span>
                        <span id="status-text">Ready to Start</span>
                    </div>
                    <div class="text-xs text-gray-400">
                        <p>üñê <b>Pinch/Open Hand:</b> Expand/Shrink Particles</p>
                        <p>‚ÜîÔ∏è <b>Move Hand:</b> Rotate Vertical & Horizontal</p>
                    </div>
                </div>
            </div>

            <!-- Camera Preview & Controls -->
            <div class="glass-panel rounded-xl p-3 flex flex-col items-center interactive-element">
                <!-- 
                     Fixed Aspect Ratio Container 
                     w-32 (128px) / h-24 (96px) = 1.333 (4:3 Aspect Ratio)
                -->
                <div class="relative w-32 h-24 bg-black rounded-lg overflow-hidden border border-gray-700 shadow-inner group">
                    <video class="input_video" playsinline></video>
                    <!-- REMOVED transform scale-x-[-1] to un-mirror the camera -->
                    <canvas class="output_canvas absolute top-0 left-0 w-full h-full object-cover"></canvas>
                    
                    <!-- Start Button Overlay (Required for Mobile Permissions) -->
                    <div id="start-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-90 z-20 cursor-pointer">
                        <div class="text-center">
                            <button id="start-btn" class="bg-blue-600 hover:bg-blue-500 text-white text-xs font-bold py-1 px-3 rounded-full transition shadow-lg border border-blue-400">
                                START
                            </button>
                        </div>
                    </div>

                    <div id="loading-spinner" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 hidden">
                        <div class="loader"></div>
                    </div>
                    
                    <!-- Error Message Overlay -->
                    <div id="error-overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-red-900 bg-opacity-95 hidden p-3 text-center">
                        <p id="error-title" class="text-xs font-bold text-white mb-1">Camera Access Failed</p>
                        <p id="error-desc" class="text-[10px] text-gray-200 leading-tight">Check permissions.</p>
                    </div>
                </div>
                
                <div class="mt-3 w-full">
                    <label class="text-xs text-gray-400 block mb-1">Particle Color</label>
                    <div class="flex items-center space-x-2">
                        <input type="color" id="color-picker" value="#4aa8ff" class="w-8 h-8 rounded cursor-pointer border-none bg-transparent">
                        <span class="text-xs text-gray-300 font-mono" id="color-hex">#4aa8ff</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer Data -->
        <div class="flex justify-end">
            <div class="glass-panel rounded-lg px-4 py-2 text-right">
                <div class="text-xs text-gray-400 uppercase tracking-widest">Active Particles</div>
                <div class="text-xl font-mono text-white font-bold">15,000</div>
            </div>
        </div>
    </div>

<script>
    // --- Configuration ---
    const CONFIG = {
        particleCount: 15000,
        sphereRadius: 18,
        ringInner: 24,
        ringOuter: 45,
        baseColor: 0x4aa8ff,
        lerpFactor: 0.05, 
        deadZone: 0.08, // 8% center area where no rotation happens
        historySize: 6   // Number of frames to average
    };

    // --- State Management ---
    const state = {
        targetScale: 1,
        currentScale: 1,
        targetRotationY: 0,
        currentRotationY: 0,
        targetRotationX: 0.2, // Slight initial tilt
        currentRotationX: 0.2,
        handDetected: false,
        pinchDistance: 0,
        
        // History buffers for Weighted Moving Average
        xHistory: [],
        yHistory: [] 
    };

    // --- Three.js Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.008);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 80;
    camera.position.y = 20;
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // --- Particle System Generation (Saturn) ---
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = [];
    const originalPositions = []; 
    const randomness = []; 

    // 1. Generate Planet Sphere
    for (let i = 0; i < CONFIG.particleCount * 0.4; i++) {
        const phi = Math.acos(-1 + (2 * i) / (CONFIG.particleCount * 0.4));
        const theta = Math.sqrt((CONFIG.particleCount * 0.4) * Math.PI) * phi;

        const r = CONFIG.sphereRadius + (Math.random() - 0.5) * 1.5; 
        
        const x = r * Math.cos(theta) * Math.sin(phi);
        const y = r * Math.sin(theta) * Math.sin(phi);
        const z = r * Math.cos(phi);

        positions.push(x, y, z);
        originalPositions.push(x, y, z);
        randomness.push(Math.random(), Math.random(), Math.random());
    }

    // 2. Generate Rings
    const ringCount = CONFIG.particleCount * 0.6;
    for (let i = 0; i < ringCount; i++) {
        const r = THREE.MathUtils.randFloat(CONFIG.ringInner, CONFIG.ringOuter);
        const theta = Math.random() * Math.PI * 2;
        
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        const y = (Math.random() - 0.5) * 1.5; 

        positions.push(x, y, z);
        originalPositions.push(x, y, z);
        randomness.push(Math.random(), Math.random(), Math.random());
    }

    particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randomness, 3));

    const particlesMaterial = new THREE.PointsMaterial({
        color: CONFIG.baseColor,
        size: 0.6,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
    });

    const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particleSystem);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // --- Interaction Logic ---

    // UI Listeners
    const colorPicker = document.getElementById('color-picker');
    const colorHex = document.getElementById('color-hex');

    colorPicker.addEventListener('input', (e) => {
        const color = new THREE.Color(e.target.value);
        particlesMaterial.color = color;
        colorHex.textContent = e.target.value;
    });

    // Helper: Calculate Weighted Average
    function getWeightedAverage(history) {
        let sum = 0;
        let weightSum = 0;
        // Apply weights: Newest (end of array) gets higher weight
        for(let i=0; i<history.length; i++) {
            const weight = i + 1; // 1, 2, 3...
            sum += history[i] * weight;
            weightSum += weight;
        }
        return sum / weightSum;
    }

    // MediaPipe Setup
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    const statusText = document.getElementById('status-text');
    const statusInd = document.getElementById('status-indicator');
    const loader = document.getElementById('loading-spinner');
    const startBtn = document.getElementById('start-btn');
    const startOverlay = document.getElementById('start-overlay');
    const errorOverlay = document.getElementById('error-overlay');
    const errorTitle = document.getElementById('error-title');
    const errorDesc = document.getElementById('error-desc');

    function onResults(results) {
        if (loader.style.display !== 'none') {
            loader.style.display = 'none';
            statusText.textContent = "Tracking Active";
            statusInd.classList.remove('bg-yellow-500');
            statusInd.classList.add('bg-green-500');
        }

        canvasElement.width = results.image.width;
        canvasElement.height = results.image.height;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            state.handDetected = true;

            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            // --- 1. SMOOTHING (Weighted Moving Average) ---
            
            // Add current raw values to history
            const rawX = landmarks[9].x;
            const rawY = landmarks[9].y;

            state.xHistory.push(rawX);
            state.yHistory.push(rawY);

            // Keep history at fixed size
            if (state.xHistory.length > CONFIG.historySize) state.xHistory.shift();
            if (state.yHistory.length > CONFIG.historySize) state.yHistory.shift();

            // Calculate smoothed values
            const smoothedX = getWeightedAverage(state.xHistory);
            const smoothedY = getWeightedAverage(state.yHistory);


            // --- 2. GESTURE LOGIC with DEAD ZONES ---

            // Horizontal (Rotation Y)
            const xOffsetRaw = smoothedX - 0.5;
            let xOffsetApplied = 0;

            // Dead Zone Check
            if (Math.abs(xOffsetRaw) > CONFIG.deadZone) {
                // We shift the value so rotation starts at 0 right after the deadzone
                // instead of jumping.
                // e.g. if Deadzone is 0.1, and Input is 0.11, result is 0.01
                const sign = Math.sign(xOffsetRaw);
                xOffsetApplied = xOffsetRaw - (sign * CONFIG.deadZone);
                
                // Scale up slightly to compensate for lost range
                // Range remaining is 0.5 - deadZone
                const rangeScale = 0.5 / (0.5 - CONFIG.deadZone); 
                xOffsetApplied *= rangeScale;
            }

            // Apply Non-Linear Sensitivity
            const sensitivity = 5;
            const curvature = 1.3;
            state.targetRotationY = Math.sign(xOffsetApplied) * Math.pow(Math.abs(xOffsetApplied), curvature) * sensitivity;

            
            // Vertical (Rotation X) - Same Logic
            const yOffsetRaw = 0.5 - smoothedY; // Invert for natural feel
            let yOffsetApplied = 0;

            if (Math.abs(yOffsetRaw) > CONFIG.deadZone) {
                const sign = Math.sign(yOffsetRaw);
                yOffsetApplied = yOffsetRaw - (sign * CONFIG.deadZone);
                const rangeScale = 0.5 / (0.5 - CONFIG.deadZone);
                yOffsetApplied *= rangeScale;
            }

            state.targetRotationX = yOffsetApplied * 4;


            // 3. EXPANSION (Pinch)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const wrist = landmarks[0];

            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const scaleRef = Math.hypot(wrist.x - landmarks[5].x, wrist.y - landmarks[5].y);
            
            const normalizedOpenness = pinchDist / scaleRef;
            let expansion = (normalizedOpenness - 0.2) * 2.5; 
            
            if (expansion < 0.1) expansion = 0.1;
            if (expansion > 4.0) expansion = 4.0;
            
            state.targetScale = expansion;

        } else {
            state.handDetected = false;
            // Clear history so next hand entry starts fresh
            state.xHistory = [];
            state.yHistory = [];
            
            state.targetScale = 1;
            
            // Idle animation
            state.targetRotationY += 0.002;
            state.targetRotationX = state.currentRotationX * 0.95 + 0.2 * 0.05; 
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // Using "ideal" constraints to prevent "OverconstrainedError" on mobiles
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        // We do NOT strictly enforce 320x240 here in the constructor options 
        // to avoid crashes on devices that don't support it.
        // The width/height in options here are mainly for aspect ratio processing.
        width: 320, 
        height: 240
    });
    
    // --- Manual Start Logic for Mobile ---
    startBtn.addEventListener('click', () => {
        
        // 1. CRITICAL: Check if running as a file
        if (window.location.protocol === 'file:') {
            errorTitle.textContent = "Security Error";
            errorDesc.textContent = "Browsers block camera access on local files (file://). You must run this using a local server (http://localhost) or host it online (HTTPS).";
            startOverlay.style.display = 'none';
            errorOverlay.style.display = 'flex';
            statusText.textContent = "Protocol Error";
            statusInd.classList.remove('bg-yellow-500');
            statusInd.classList.add('bg-red-500');
            return;
        }

        // 2. Check for Secure Context
        if (!window.isSecureContext && window.location.hostname !== 'localhost') {
             errorTitle.textContent = "Insecure Context";
            errorDesc.textContent = "Camera access requires HTTPS or Localhost.";
            startOverlay.style.display = 'none';
            errorOverlay.style.display = 'flex';
            return;
        }

        startOverlay.style.display = 'none';
        loader.style.display = 'flex';
        statusText.textContent = "Starting Camera...";
        
        cameraUtils.start()
            .then(() => {
                console.log("Camera started successfully");
            })
            .catch(err => {
                console.error("Camera failed:", err);
                loader.style.display = 'none';
                errorOverlay.style.display = 'flex';
                
                // Helpful error parsing
                if (err.name === 'NotAllowedError') {
                    errorTitle.textContent = "Permission Denied";
                    errorDesc.textContent = "Please allow camera access in your browser settings.";
                } else if (err.name === 'NotFoundError') {
                    errorTitle.textContent = "No Camera";
                    errorDesc.textContent = "No camera device found.";
                } else {
                    errorTitle.textContent = "Camera Error";
                    errorDesc.textContent = err.message || "Unknown error.";
                }
                
                statusText.textContent = "Camera Failed";
                statusInd.classList.remove('bg-yellow-500');
                statusInd.classList.add('bg-red-500');
            });
    });

    // --- Animation Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();

        // 1. Smooth Interpolation (LERP)
        // Lerp factor determines the 'lag' or 'weight'. 
        state.currentScale += (state.targetScale - state.currentScale) * CONFIG.lerpFactor;
        
        if (state.handDetected) {
            // Active control
            state.currentRotationY += (state.targetRotationY - state.currentRotationY) * CONFIG.lerpFactor;
            state.currentRotationX += (state.targetRotationX - state.currentRotationX) * CONFIG.lerpFactor;
        } else {
            // Idle spin
            state.currentRotationY += 0.002;
            state.currentRotationX += (state.targetRotationX - state.currentRotationX) * 0.05;
        }

        // 2. Apply Rotations
        particleSystem.rotation.y = state.currentRotationY;
        particleSystem.rotation.x = state.currentRotationX;
        particleSystem.rotation.z = Math.cos(time * 0.1) * 0.05;

        // 3. Update Particles
        const positionsAttribute = particlesGeometry.attributes.position;
        const positionsArray = positionsAttribute.array;

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            const ox = originalPositions[ix];
            const oy = originalPositions[iy];
            const oz = originalPositions[iz];

            // Scale
            let px = ox * state.currentScale;
            let py = oy * state.currentScale;
            let pz = oz * state.currentScale;

            // Noise / Life
            const noise = Math.sin(time * 2 + i * 0.1) * 0.2 * state.currentScale;
            
            if (i > CONFIG.particleCount * 0.4) {
                 // Ring orbital drift
                 px += Math.sin(time + i) * 0.1;
                 pz += Math.cos(time + i) * 0.1;
            } else {
                // Sphere breathing
                px += noise;
                py += noise;
                pz += noise;
            }

            positionsArray[ix] = px;
            positionsArray[iy] = py;
            positionsArray[iz] = pz;
        }

        positionsAttribute.needsUpdate = true;
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>